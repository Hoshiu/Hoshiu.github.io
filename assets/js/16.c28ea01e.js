(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{632:function(e,s,r){"use strict";r.r(s);var t=r(9),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,r=e._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"关于学习-nest-js-的感想"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#关于学习-nest-js-的感想"}},[e._v("#")]),e._v(" 关于学习 Nest.js 的感想")]),e._v(" "),r("p",[e._v("其实学习下来感觉个人非常喜欢 Nest.js，但比较可惜的是在国内不温不火，毕竟国内的公司感觉大多都偏向直接用 Golang 或者 Java 这种后端语言来写后端，甚至于 egg.js。但 Nest 作为一个 Node.js 的 web server 框架，在我学习前后端交互时有所获益。")]),e._v(" "),r("p",[e._v("之前有幸参加过武汉的前端充电站，根据淘系团队的讲解，感觉 midway 也很有学习的价值，之后可以参考学习。")]),e._v(" "),r("h2",{attrs:{id:"框架简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#框架简介"}},[e._v("#")]),e._v(" 框架简介")]),e._v(" "),r("blockquote",[r("p",[e._v("Nest 是一个用于构建高效，可扩展的 "),r("a",{attrs:{href:"http://nodejs.cn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Node.js"),r("OutboundLink")],1),e._v(" 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全支持 "),r("a",{attrs:{href:"https://www.tslang.cn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("TypeScript"),r("OutboundLink")],1),e._v("（但仍然允许开发人员使用纯 JavaScript 编写代码）并结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。")]),e._v(" "),r("p",[e._v("在底层，Nest使用强大的 HTTP Server 框架，如 Express（默认）和 Fastify。Nest 在这些框架之上提供了一定程度的抽象，同时也将其 API 直接暴露给开发人员。这样可以轻松使用每个平台的无数第三方模块。")])]),e._v(" "),r("p",[e._v("简单来说， Nest.js 是一款 Node.js 的后端框架，胜在"),r("strong",[e._v("规范化")]),e._v("和"),r("strong",[e._v("开箱即用")]),e._v("，在国外开发者社区非常流行，值得尝试一下。")]),e._v(" "),r("h2",{attrs:{id:"前置准备"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前置准备"}},[e._v("#")]),e._v(" 前置准备")]),e._v(" "),r("ul",[r("li",[e._v("TypeScript/JavaScript")]),e._v(" "),r("li",[e._v("HTTP")]),e._v(" "),r("li",[e._v("MySQL/MongoDB, etc")]),e._v(" "),r("li",[e._v("Node.js >= 10.13.0")])]),e._v(" "),r("p",[e._v("官网给出了使用 Nest.js 构建项目的方法，建议使用 Nest CLI 构建项目，脚手架的好处在于相关项目文件的生成便利。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("npm i -g @nestjs/cli\nnest new project-name\n")])])]),r("p",[e._v("初始化项目后，进入该项目运行即可。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("cd project-name\nyarn start:dev\t\t//使用 dev 模式启动可以自动监测文件内容的变化，并自动重启服务，便于开发。\n")])])]),r("blockquote",[r("p",[e._v("此命令启动 HTTP 服务监听定义在 "),r("code",[e._v("src/main.ts")]),e._v(" 文件中定义的端口号。在应用程序运行后, 打开浏览器并访问 "),r("code",[e._v("http://localhost:3000/")]),e._v("。 你应该看到 "),r("code",[e._v("Hello world!")]),e._v(" 信息。")])]),e._v(" "),r("p",[e._v("接下来需要使用 MySQL 操作数据库，当然并不只限于它，任何你偏好的 SQL 或 NoSQL 皆可，这里我使用 MySQL 进行学习。")]),e._v(" "),r("h2",{attrs:{id:"代码编写"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代码编写"}},[e._v("#")]),e._v(" 代码编写")]),e._v(" "),r("p",[e._v("后端主要遵循 MVC 模式。同理，Nest.js 分为 controller、service 和 model，分别定义了路由，数据库操作以及数据库的模型。")]),e._v(" "),r("p",[e._v("以最经典的用户模块来看，编写一个后端的用户接口，来完成登录注册的相关内容。")]),e._v(" "),r("h3",{attrs:{id:"创建-module"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建-module"}},[e._v("#")]),e._v(" 创建 Module")]),e._v(" "),r("p",[e._v("首先创建一个"),r("code",[e._v("User")]),e._v("模块")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("nest g module user server\n")])])]),r("p",[e._v("Nest CLi 会在 "),r("code",[e._v("src/server/user")]),e._v("下创建一个名为 "),r("code",[e._v("user.module.ts")]),e._v("的文件，它用来组织应用程序结构。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// user.module.ts\nimport { Module } from '@nestjs/common';\n\n@Module({})\nexport class UserModule {}\n")])])]),r("p",[e._v("我们需要在根模块中引入 User 模块来使用它，即"),r("code",[e._v("app.module.ts")]),e._v("，但基于上面创建 User 模块的指令，"),r("code",[e._v("app.module.ts")]),e._v("中的代码已经自行引入该模块。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// app.module.ts\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { UserModule } from './server/user/user.module'; // 自动引入\n\n@Module({\n  imports: [UserModule], // 自动引入\n  controllers: [AppController],\n  providers: [AppService]\n})\nexport class AppModule {}\n")])])]),r("h3",{attrs:{id:"创建-controller"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建-controller"}},[e._v("#")]),e._v(" 创建 Controller")]),e._v(" "),r("p",[e._v("@Controll 装饰器用来处理对应的请求路由，控制器的目的是接收应用的特定请求。"),r("strong",[e._v("路由")]),e._v("机制控制哪个控制器接收哪些请求。通常，每个控制器有多个路由，不同的路由可以执行不同的操作。")]),e._v(" "),r("p",[e._v("与上面同理，输入以下内容")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("nest g controller user server\n")])])]),r("p",[e._v("会发现"),r("code",[e._v("src/server/user")]),e._v("中多了一个"),r("code",[e._v("user.controller.ts")]),e._v("文件，它用来处理相应的路由请求。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// user.controller.ts\nimport { Get } from '@nestjs/common';\nimport { UserService } from './user.service';\ninterface UserResponse<T = [] | boolean | User> {\n  code: number;\n  data?: T;\n  message: string;\n}\n\n@Controller('user')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Get('users')\n  async findAll(): Promise<UserResponse<User[]>> {\n    return {\n      code: 200,\n      data: await this.userService.findAll(),\n      message: 'Success.',\n    };\n  }\n}\n")])])]),r("p",[e._v("这里我们导入一个 Get 方法，并创建了一个路径为"),r("code",[e._v("user/users")]),e._v("的路由，当我们通过Get 请求访问"),r("code",[e._v("http://localhost:3000/user/users")]),e._v("时，会返回该异步方法的结果。")]),e._v(" "),r("p",[e._v("在创建 Controller 文件时，引入了 "),r("code",[e._v("./user.service")]),e._v("，是因为 controller 并不能直接查询数据库并返回结果，而是需要转交给 Provider来处理，这种方式很常见，例如 Redux Thunk、Vuex。")]),e._v(" "),r("h3",{attrs:{id:"创建-provider"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建-provider"}},[e._v("#")]),e._v(" 创建 Provider")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("nest g service user server\n")])])]),r("p",[r("code",[e._v("provider")]),e._v(" 我们可以简单地从字面意思来理解，就是"),r("strong",[e._v("服务的提供者")]),e._v("，它可以提供相应的"),r("strong",[e._v("数据库操作服务")]),e._v("。")]),e._v(" "),r("p",[r("code",[e._v("Providers")]),e._v(" 是纯粹的 "),r("code",[e._v("JavaScript")]),e._v(" 类，在其类声明之前带有 "),r("code",[e._v("@Injectable()")]),e._v("装饰器。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// user.service.ts\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class UserService {}\n")])])]),r("p",[e._v("这里创建的了service 用来进行数据库操作，事实上它还可以进行一些校验操作。比如 "),r("strong",[e._v("JWT")]),e._v(" 登录校验等，封装一个对用户权限进行校验的策略类来为模块提供响应的服务。")]),e._v(" "),r("p",[e._v("最终 "),r("code",[e._v("user.moudule.ts")]),e._v("文件变成如下结果")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// user.module.ts\nimport { Module } from '@nestjs/common';\nimport { UserController } from './user.controller';\nimport { UserService } from './user.service';\n\n@Module({\n  controllers: [UserController],\n  providers: [UserService]\n})\nexport class UserModule {}\n")])])]),r("p",[e._v("此时，基本的内容有所完成，我们可以开始连接数据库了。")]),e._v(" "),r("h2",{attrs:{id:"数据库相关操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库相关操作"}},[e._v("#")]),e._v(" 数据库相关操作")]),e._v(" "),r("h3",{attrs:{id:"连接-mysql-数据库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#连接-mysql-数据库"}},[e._v("#")]),e._v(" 连接 MySQL 数据库")]),e._v(" "),r("blockquote",[r("p",[e._v("为了与 "),r("code",[e._v("SQL")]),e._v("和 "),r("code",[e._v("NoSQL")]),e._v(" 数据库集成，"),r("code",[e._v("Nest")]),e._v(" 提供了 "),r("code",[e._v("@nestjs/typeorm")]),e._v(" 包。"),r("code",[e._v("Nest")]),e._v(" 使用"),r("a",{attrs:{href:"https://github.com/typeorm/typeorm",target:"_blank",rel:"noopener noreferrer"}},[e._v("TypeORM"),r("OutboundLink")],1),e._v("是因为它是 "),r("code",[e._v("TypeScript")]),e._v(" 中最成熟的对象关系映射器( "),r("code",[e._v("ORM")]),e._v(" )。因为它是用 "),r("code",[e._v("TypeScript")]),e._v(" 编写的，所以可以很好地与 "),r("code",[e._v("Nest")]),e._v(" 框架集成。为所选数据库安装相关的客户端 "),r("code",[e._v("API")]),e._v(" 库。")])]),e._v(" "),r("p",[e._v("我是用的是 MySQL，需要安装相应的"),r("code",[e._v("API")]),e._v("库")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("npm install --save @nestjs/typeorm typeorm mysql2\n")])])]),r("p",[e._v("将 "),r("code",[e._v("TypeOrmModule")]),e._v(" 导入"),r("code",[e._v("AppModule")]),e._v(" 。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// app.module.ts\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { Connection } from 'typeorm';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { UserModule } from './server/user/user.module';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'mysql',\n      host: 'localhost',\n      port: XXXX,\n      username: 'XXXXX',\n      password: 'XXXXXX',\n      database: 'users_info',\n      entities: [__dirname + '/**/*.entity{.ts,.js}'],\n      synchronize: false,\n    }),\n    UserModule,\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {\n  constructor(private connection: Connection) {}\n}\n")])])]),r("p",[e._v("接下来就是 数据库的"),r("code",[e._v("CRUD")]),e._v("，来完善我们的登录注册接口。")]),e._v(" "),r("h3",{attrs:{id:"crud"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#crud"}},[e._v("#")]),e._v(" CRUD")]),e._v(" "),r("p",[e._v("CRUD，意为对数据库的增删改查。")]),e._v(" "),r("p",[e._v("此前我们已经写好了模块（Module）、路由（Controller）、以及相关的数据库操作服务（Provider）。实际上，Controller 中并不能直接更改数据库，它需要调用 Provider 中的方法来操作数据库，因此我们在 "),r("code",[e._v("user.service.ts")]),e._v("中增加一些操作，并使用 "),r("code",[e._v("async")]),e._v(" 函数来处理异步的过程。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import { Injectable } from '@nestjs/common';\nimport { User } from './user.entity';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { CreateUserDTO, EditUserDTO, LoginUserDTO } from './user.dto';\n\n@Injectable()\nexport class UserService {\n  constructor(\n    @InjectRepository(User)\n    private readonly userRepository: Repository<User>,\n  ) {}\n\n  // 查找所有用户\n  async findAll(): Promise<User[]> {\n    const users = await this.userRepository.find();\n    return users;\n  }\n\n  // 查找单个用户\n  async findOne(id: string): Promise<User> {\n    return await this.userRepository.findOne(id);\n  }\n\n  // 添加单个用户\n  async addOne(body: CreateUserDTO): Promise<void> {\n    await this.userRepository.insert(body);\n  }\n\n  // 编辑单个用户\n  async editOne(id: string, body: EditUserDTO): Promise<void> {\n    await this.userRepository.update(id, body);\n  }\n\n  // 删除单个用户\n  async deleteOne(id: string): Promise<void> {\n    await this.userRepository.delete(id);\n  }\n\n  // 登录\n  async loginOne(body: LoginUserDTO): Promise<boolean> {\n    const user = await this.userRepository.findOne(body.id);\n    if (user.password === body.password) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n")])])]),r("p",[e._v("这个时候，我们需要在"),r("code",[e._v("src/user")]),e._v("路径中新增一个名为"),r("code",[e._v("user.dto.ts")]),e._v("的文件，使用其来对数据类型进行定义，用以规范数据。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// user.dto.ts\nexport class CreateUserDTO {\n  readonly id: string;\n  readonly name: string;\n  readonly password: string;\n}\n\nexport class EditUserDTO {\n  readonly name: string;\n  readonly password: string;\n}\n\nexport class LoginUserDTO {\n  readonly id: string;\n  readonly password: string;\n}\n")])])]),r("p",[e._v("如此，我们可以在 "),r("code",[e._v("user.controller.ts")]),e._v(" 中设置路由并调用相应方法了。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// user.controller.ts\nimport {\n  Body,\n  Controller,\n  Delete,\n  Get,\n  Param,\n  Post,\n  Put,\n} from '@nestjs/common';\nimport { UserService } from './user.service';\nimport { User } from './user.entity';\nimport { CreateUserDTO, EditUserDTO, LoginUserDTO } from './user.dto';\n\ninterface UserResponse<T = [] | boolean | User> {\n  code: number;\n  data?: T;\n  message: string;\n}\n\n@Controller('user')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Get('users')\n  async findAll(): Promise<UserResponse<User[]>> {\n    return {\n      code: 200,\n      data: await this.userService.findAll(),\n      message: 'Success.',\n    };\n  }\n\n  // GET /user/:id\n  @Get(':id')\n  async findOne(@Param('id') id: string): Promise<UserResponse<User>> {\n    const data = await this.userService.findOne(id);\n    if (data) {\n      return {\n        code: 200,\n        data: data,\n        message: 'Success.',\n      };\n    } else {\n      return {\n        code: 404,\n        data: null,\n        message: 'Can not found.',\n      };\n    }\n  }\n\n  // POST /user\n  @Post()\n  async addOne(@Body() body: CreateUserDTO): Promise<UserResponse> {\n    await this.userService.addOne(body);\n    return {\n      code: 200,\n      message: 'Success.',\n    };\n  }\n  // POST /user/login\n  @Post('/login')\n  async loginOne(@Body() body: LoginUserDTO): Promise<UserResponse> {\n    return {\n      code: 200,\n      data: await this.userService.loginOne(body),\n      message: 'Success.',\n    };\n  }\n\n  // PUT /user/:id\n  @Put(':id')\n  async editOne(\n    @Param('id') id: string,\n    @Body() body: EditUserDTO,\n  ): Promise<UserResponse> {\n    await this.userService.editOne(id, body);\n    return {\n      code: 200,\n      data: await this.userService.findOne(id),\n      message: 'Success.',\n    };\n  }\n\n  // DELETE /user/:id\n  @Delete(':id')\n  async deleteOne(@Param('id') id: string): Promise<UserResponse> {\n    await this.userService.deleteOne(id);\n    return {\n      code: 200,\n      message: 'Success.',\n    };\n  }\n}\n")])])]),r("p",[e._v("如此便完成了一个基本的 "),r("code",[e._v("CRUD")]),e._v(" 操作，可以通过 "),r("code",[e._v("Postman")]),e._v(" 或者 "),r("code",[e._v("Swagger")]),e._v(" 之类的接口自测工具进行测试。")]),e._v(" "),r("h3",{attrs:{id:"接口测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口测试"}},[e._v("#")]),e._v(" 接口测试")]),e._v(" "),r("h4",{attrs:{id:"get-user-users"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get-user-users"}},[e._v("#")]),e._v(" GET /user/users")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/img/NestJs/image-20210922222815825.png"),alt:"GetAll"}}),e._v(" "),r("p",[e._v("这里我已经添加一些初始数据。")]),e._v(" "),r("h4",{attrs:{id:"post-users"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#post-users"}},[e._v("#")]),e._v(" POST /users")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/img/NestJs/image-20210923004604125.png"),alt:"PostOne"}}),e._v(" "),r("p",[e._v("向其中写入一条数据，返回写入成功的响应。")]),e._v(" "),r("h4",{attrs:{id:"get-user-id"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get-user-id"}},[e._v("#")]),e._v(" GET /user/:id")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/img/NestJs/image-20210923004822710.png"),alt:"GetOne"}}),e._v(" "),r("p",[e._v("查看刚才写入的用户信息，返回成功。")]),e._v(" "),r("h4",{attrs:{id:"put-user-id"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#put-user-id"}},[e._v("#")]),e._v(" PUT /user/:id")]),e._v(" "),r("p",[e._v("有时我们需要修改用户数据，这时需要发送一个 "),r("code",[e._v("PUT")]),e._v(" 请求")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/img/NestJs/image-20210923005052789.png"),alt:"PutOne"}}),e._v(" "),r("h4",{attrs:{id:"delete-user-id"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#delete-user-id"}},[e._v("#")]),e._v(" DELETE /user/:id")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/img/NestJs/image-20210923005131674.png"),alt:"DeleteOne"}}),e._v(" "),r("p",[e._v("再去查看该"),r("code",[e._v("id")]),e._v("对应的用户，已经找不到了。")]),e._v(" "),r("img",{attrs:{src:e.$withBase("/img/NestJs/image-20210923010019689.png"),alt:"DeleteOne"}}),e._v(" "),r("p",[e._v("如此，便完成了一个基本的 "),r("code",[e._v("CRUD")]),e._v("，前端通过"),r("code",[e._v("Ajax")]),e._v("请求访问该端口，通过不同方法即可请求到数据，做到了前后端交互。")]),e._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("其实在学习过程中还是遇到了很多坑的，自己也是查阅了官方文档以及许多优秀作者的博客才得以理解这些基本的功能，。简单来说 "),r("code",[e._v("Nest.js")]),e._v("是一个比较好用的 "),r("code",[e._v("Node.js")]),e._v("应用，但其中还有很多东西可以完善，我们大可以进行对数据库数据进行更多限制，以及一些错误捕获，还有之前提到的 "),r("strong",[e._v("JWT")]),e._v("登陆校验等等，都是我们完善的方向。这个就需要后面去研究学习了。")]),e._v(" "),r("p",[e._v("对作为学习前端的我来说，这让我了解了部分后端的工作，便于理解前后端交互的过程。")]),e._v(" "),r("p",[e._v("接下来对 Midway 非常感兴趣，希望有时间能够研究一下。")])])}),[],!1,null,null,null);s.default=n.exports}}]);